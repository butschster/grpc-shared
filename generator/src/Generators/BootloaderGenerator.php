<?php

declare(strict_types=1);

namespace Generator\Generators;

use Shared\gRPC\Bootloader\CommandMapperBootloader;
use Shared\gRPC\Service\GrpcClientCore;
use Shared\gRPC\Service\ServiceLocator;
use Shared\gRPC\Service\ServiceLocatorInterface;
use Psr\Container\ContainerInterface;
use Spiral\Boot\Bootloader\Bootloader;
use Spiral\Boot\EnvironmentInterface;
use Spiral\Config\ConfiguratorInterface;
use Spiral\Core\Container;
use Spiral\Core\InterceptableCore;
use Spiral\Files\FilesInterface;
use Spiral\Reactor\FileDeclaration;
use Spiral\Reactor\InterfaceDeclaration;
use Spiral\Reactor\Partial\Method;
use Spiral\Reactor\Partial\PhpNamespace;
use Spiral\Reactor\Writer;
use Spiral\RoadRunnerBridge\GRPC\LocatorInterface;

final class BootloaderGenerator implements GeneratorInterface
{
    private const BOOTLOADER_NAME = 'ServiceBootloader';
    private const READONLY_COMMENT = 'Don\'t edit this method manually, it is generated by GRPC services generator.';

    public function __construct(
        private readonly FilesInterface $files,
    ) {
    }

    /**
     * @param non-empty-string[] $files
     * @param non-empty-string $targetPath
     * @param non-empty-string $namespace
     */
    public function run(array $files, string $targetPath, string $namespace): void
    {
        $file = $this->files->exists($this->getPath($targetPath))
            ? FileDeclaration::fromCode($this->files->read($this->getPath($targetPath)))
            : $this->createBootloader($namespace);

        $this->updateInitConfigMethod($file, $files);
        $this->updateInitServicesMethod($namespace, $file, $files);

        (new Writer($this->files))->write($this->getPath($targetPath), $file);
    }

    /**
     * @param non-empty-string[] $files
     */
    private function updateInitConfigMethod(FileDeclaration $file, array $files): void
    {
        $result = [];
        $port = 9000;
        foreach ($files as $service) {
            if (!\str_ends_with($service, 'Interface.php')) {
                continue;
            }

            $interfaceFile = FileDeclaration::fromCode($this->files->read($service));
            $interface = $interfaceFile->getInterfaces()->getIterator()->current();
            $interfaceName = $interface->getName();

            \assert($interfaceName !== null);

            $className = $this->generateClientClassName($interface);

            $result[] = \sprintf(
                '%s::class => [\'host\' => $env->get(\'%s_HOST\', \'127.0.0.1:%d\')],',
                $className,
                \strtoupper(
                    \trim(
                        implode(
                            '_',
                            \preg_split('/(?=[A-Z])/', $className),
                        ),
                        '_',
                    ),
                ),
                $port,
            );
            $port++;
        }

        $body = \sprintf(
            <<<'EOL'
$this->config->setDefaults(
    GRPCServicesConfig::CONFIG,
    [
        'services' => [
            %s
        ],
        'interceptors' => [
            \Shared\gRPC\Interceptor\Outgoing\TokenExtractorInterceptor::class,
            \Shared\gRPC\Interceptor\Outgoing\OpenTelemetryInterceptor::class,
        ],
    ]
);
EOL,
            \implode("\n\t\t\t", $result),
        );

        $file->getClass(self::BOOTLOADER_NAME)->getMethod('initConfig')->setBody($body);
    }

    /**
     * @param non-empty-string[] $files
     */
    private function updateInitServicesMethod(string $namespace, FileDeclaration $file, array $files): void
    {
        $method = $file->getClass(self::BOOTLOADER_NAME)->getMethod('initServices');
        $method->addParameter('container')->setType(ContainerInterface::class);
        $method->setBody('');

        foreach ($files as $service) {
            if (!\str_ends_with($service, 'Interface.php')) {
                continue;
            }

            $this->registerServiceClient($namespace, $method, $file, $service);
        }
    }

    /**
     * @param non-empty-string $service
     */
    private function registerServiceClient(
        string $appNamespace,
        Method $servicesMethod,
        FileDeclaration $bootloader,
        string $service,
    ): void {
        $interfaceFile = FileDeclaration::fromCode($this->files->read($service));
        /** @var InterfaceDeclaration $interface */
        $interface = $interfaceFile->getInterfaces()->getIterator()->current();
        /** @var PhpNamespace $interfaceNamespace */
        $interfaceNamespace = $interfaceFile->getNamespaces()->getIterator()->current();
        /** @var PhpNamespace $namespace */
        $namespace = $bootloader->getNamespaces()->getIterator()->current();

        $className = $this->generateClientClassName($interface);

        $interfaceName = $interface->getName();
        \assert($interfaceName !== null);

        $servicesMethod->addBody(
            \sprintf(
                <<<'EOL'

$container->bindSingleton(
    %s::class,
    static function(GRPCServicesConfig $config) use($container): %s
    {
        $service = $config->getService(%s::class);

        $core = new InterceptableCore(new GrpcClientCore(
            $service['host'],
            ['credentials' => $service['credentials'] ?? $config->getDefaultCredentials()]
        ));

        foreach ($config->getInterceptors() as $interceptor) {
            $core->addInterceptor($container->get($interceptor));
        }

        return $container->make(%s::class, ['core' => $core]);
    }
);

EOL,
                $interfaceName,
                $interfaceName,
                $className,
                $className,
            ),
        );

        $namespace->addUse($interfaceNamespace->getName() . '\\' . $interface->getName());
        $namespace->addUse($appNamespace . '\\Service\\Client\\' . $className);
    }

    private function createBootloader(string $namespace): FileDeclaration
    {
        $file = new FileDeclaration();
        $bootloaderNamespace = $file->addNamespace($namespace . '\\' . 'Bootloader');
        $bootloaderNamespace->addUse(Bootloader::class);
        $bootloaderNamespace->addUse(ContainerInterface::class);
        $bootloader = $bootloaderNamespace->addClass(self::BOOTLOADER_NAME);
        $bootloader->setFinal(true);
        $bootloader->setExtends(Bootloader::class);
        $bootloader->setComment(['This class is read only. Please do not edit it directly.']);

        $bootloaderNamespace->addUse(ConfiguratorInterface::class);
        $bootloaderNamespace->addUse(GrpcClientCore::class);
        $bootloaderNamespace->addUse(InterceptableCore::class);
        $bootloaderNamespace->addUse(ServiceLocatorInterface::class);
        $bootloaderNamespace->addUse(LocatorInterface::class);
        $bootloaderNamespace->addUse(ServiceLocator::class);

        $bootloader
            ->addMethod('__construct')
            ->addPromotedParameter('config')
            ->setReadOnly()
            ->setPrivate()
            ->setType(ConfiguratorInterface::class);

        $bootloader->addMethod('defineDependencies')
            ->setReturnType('array')
            ->addBody(
                <<<'PHP'
return [
    CommandMapperBootloader::class,
];
PHP,
            );

        $bootloader->addMethod('defineSingletons')
            ->setReturnType('array')
            ->addBody(
                <<<'PHP'
return [
    ServiceLocatorInterface::class => ServiceLocator::class,
    LocatorInterface::class => ServiceLocator::class,
];
PHP,
            );

        $bootloaderNamespace->addUse(EnvironmentInterface::class);
        $bootloaderNamespace->addUse(CommandMapperBootloader::class);

        $initMethod = $bootloader
            ->addMethod('init')
            ->setReturnType('void')
            ->addBody(
                <<<'PHP'
$this->initConfig($env);
PHP,
            );

        $initMethod
            ->addParameter('env')
            ->setType(EnvironmentInterface::class);


        $bootloaderNamespace->addUse(Container::class);

        $bootloader
            ->addMethod('boot')
            ->setReturnType('void')
            ->addBody('$this->initServices($container);')
            ->addParameter('container')
            ->setType(Container::class);

        $bootloader
            ->addMethod('initConfig')
            ->setReturnType('void')
            ->setPrivate()
            ->setComment(self::READONLY_COMMENT)
            ->addParameter('env')
            ->setType(EnvironmentInterface::class);

        $bootloader
            ->addMethod('initServices')
            ->setReturnType('void')
            ->setPrivate()
            ->setComment(self::READONLY_COMMENT)
            ->addParameter('container')
            ->setType(Container::class);

        $bootloaderNamespace->addUse($namespace . '\\Config\\' . 'GRPCServicesConfig');

        return $file;
    }

    private function getPath(string $targetPath): string
    {
        return \sprintf('%s/Bootloader/%s.php', $targetPath, self::BOOTLOADER_NAME);
    }

    public function generateClientClassName(InterfaceDeclaration $interface): string
    {
        $className = \str_replace('Interface', '', (string)$interface->getName());
        if (!\str_ends_with($className, 'Service')) {
            $className .= 'Service';
        }

        $className .= 'Client';
        return $className;
    }
}
